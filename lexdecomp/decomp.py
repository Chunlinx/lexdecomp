"""Creates a two-channel (similar, dissimilar) distributed vector
representation of questions and candidate answer sentences. Implements the
method reported by Wang et al. (2016) [https://arxiv.org/abs/1602.07019].

Single punctuation tokens are mostly ignored, but some meaningful characters
are kept. Words out of vocabulary are representend by random vectors.

Input format:
qid     question    sentence    label

Output:
Output is stored in an HDF5 file containing three datasets: questions,
sentences and labels.
"""
import argparse
import logging
import string
from collections import namedtuple
from pathlib import Path

import h5py
import numpy as np

PUNCT = set(string.punctuation) - set('$%#')

# global parameters (changed in main(), by CLI arguments)
MAX_QUESTION = 20
MAX_SENTENCE = 40


class EmbeddingMatrix:
    @classmethod
    def load(cls, array_file, vocabulary_file):
        matrix = np.load(array_file, mmap_mode='r')
        with open(vocabulary_file, 'r') as fin:
            vocabulary = [word.strip() for word in fin]
        return cls(vocabulary, matrix)

    def __init__(self, vocabulary, matrix):
        self.index = {w: i for i, w in enumerate(vocabulary)}
        self.matrix = matrix
        self.dimension = matrix.shape[1]

    def __getitem__(self, word):
        return self.matrix[self.index[word]]

    def __contains__(self, item):
        return item in self.index

    def __len__(self):
        return len(self.index)


def vectorize(sentence, embeddings, size_limit, ignore_case=False):
    """Creates a vectorized representation (embedding matrix) of a sentence."""
    if ignore_case:
        sentence = sentence.lower()
    tokens = [w for w in sentence.strip().split() if w not in PUNCT]
    tokens = tokens[:size_limit]  # truncating sentence

    vectors = []
    for t in tokens:
        if t in embeddings:
            vectors.append(embeddings[t])
        else:  # OOV word
            random_vector = np.random.uniform(-0.25, 0.25,
                                              size=embeddings.dimension)
            vectors.append(random_vector)
    vectorized = np.array(vectors).T  # dimension lines x len(tokens) columns
    return vectorized


def compute_attention(question_matrix, sentence_matrix):
    """Computes the Attention Matrix of `question_matrix` (S) and
    `sentence_matrix` (T).
    """
    # computing unit vectors
    norms = np.linalg.norm(question_matrix, axis=0)
    norms = norms[np.newaxis, :]
    qmat = question_matrix / norms

    # computing unit vectors
    norms = np.linalg.norm(sentence_matrix, axis=0)
    norms = norms[np.newaxis, :]
    smat = sentence_matrix / norms

    # With unit vectors, the cosine similarity between every word vector can
    # be computed as a series of dot products, implemented as
    # matrix multiplication
    attention = np.matmul(qmat.T, smat)
    return attention


def semantic_match(sentence, attention_vec):
    """Computes the semantic matching between the i-th word of a sentence (s_i)
    and the words of a target `sentence` (T).

    Implements the strategy local-w from Wang et al. (2016, sec.3.1), with w=3.

    :param sentence: a sentence matrix of shape (dim, n_tokens).
    :param attention_vec: a row (or column) from the attention matrix
    containing similarity scores of the i-th word with all the words from
    `sentence`.

    :returns: a semantic matching vector of shape (dim,), where dim is the
    embedding dimension.
    """
    w = 3  # window size
    dimension, n_tokens = sentence.shape
    k = np.argmax(attention_vec)  # position k, of the most similar word
    window = range(max(0, k-w), min(k+w, n_tokens))  # window centered on k
    vector = np.zeros(dimension)
    for i in window:
        vector += attention_vec[i] * sentence[:, i]
    return vector


def decompose(word_vec, match_vec, method='linear'):
    """Decompose `word_vec` (s_i) in two channels (similar, dissimilar) using
    the `match_vec` (s^_i).

    Implements decomposition methods from Wang et al. (2016, sec.3.2).
    """
    assert method in ('orthogonal', 'linear')

    if method == 'orthogonal':
        # About the formulas: https://en.wikipedia.org/wiki/Vector_projection#Vector_rejection  # noqa
        alpha = np.dot(word_vec, match_vec) / np.dot(match_vec, match_vec)
        positive = alpha * match_vec  # parallel to match_vec
        negative = word_vec - positive  # perpendicular
    elif method == 'linear':
        # cosine
        alpha = np.dot(word_vec, match_vec) / (
            np.linalg.norm(word_vec) * np.linalg.norm(match_vec))
        positive = alpha * word_vec
        negative = (1.0 - alpha) * word_vec
    return positive, negative


def decomp_channels(question, sentence):
    """Decomposes `question` and `sentence` (both vectorized sentences) in
    two-channel matrices.

    :param question: vectorized representation of a question, generated by
    :function:vectorize. It's a matrix of shape (`dim`, n_tokens), where
    1 <= n_tokens <= MAX_SIZE.
    :param sentence: vectorized representation of a sentence, like `question`.

    :returns: a tuple of two arrays of shape (`dim`, MAX_SIZE, `channels`),
    where MAX_SIZE is the maximum number of tokens allowed for that each
    sentence (either MAX_QUESTION or MAX_SENTENCE). Channel 0 will hold
    positive vectors and channel 1 the negative.
    """
    assert question.shape[0] == sentence.shape[0]
    dim = question.shape[0]
    channels = 2

    ch_question = np.zeros((dim, MAX_QUESTION, channels), dtype=np.float32)
    ch_sentence = np.zeros((dim, MAX_SENTENCE, channels), dtype=np.float32)

    # decomposition: similar and dissimilar channels
    attention = compute_attention(question, sentence)
    for i in range(question.shape[1]):
        word = question[:, i]  # word vector
        match_vec = semantic_match(sentence, attention[i, :])
        pos, neg = decompose(word, match_vec)
        ch_question[:, i, 0] = pos  # channel 0: positive
        ch_question[:, i, 1] = neg  # channel 1: negative

    for i in range(sentence.shape[1]):
        word = sentence[:, i]  # word vector
        match_vec = semantic_match(question, attention[:, i])
        pos, neg = decompose(word, match_vec)
        ch_sentence[:, i, 0] = pos  # channel 0: positive
        ch_sentence[:, i, 1] = neg  # channel 1: negative

    return ch_question, ch_sentence


def load_embeddings(filename):
    vectors_file = Path(filename).with_suffix('.npy')
    vocabulary_file = Path(filename).with_suffix('.voc')
    # validation of vector files
    assert vectors_file.is_file(), '%s is not a file' % vectors_file
    assert vocabulary_file.is_file(), '%s is not a file' % vocabulary_file

    return EmbeddingMatrix.load(
        vectors_file.as_posix(), vocabulary_file.as_posix())


def create_outfile(out_file, input_file, dimension):
    logging.info('creating output file: dim=%d' % dimension)

    # counting sentences
    with open(input_file) as fin:
        n_sentences = sum(1 for _ in fin)

    # creating HDF5 file
    hdf = h5py.File(out_file, mode='w')

    # preparing datasets
    channels = 2
    grp_data = hdf.create_group('data')
    grp_data.create_dataset(
        'questions', dtype=np.float32,
        shape=(n_sentences, dimension, MAX_QUESTION, channels))
    grp_data.create_dataset(
        'sentences', dtype=np.float32,
        shape=(n_sentences, dimension, MAX_SENTENCE, channels))
    grp_data.create_group('labels')

    hdf.create_group('metadata')

    return hdf


def main():
    global MAX_SENTENCE, MAX_QUESTION
    # CLI arguments
    parser = argparse.ArgumentParser(
        description='Decompose sentences in two channels')
    parser.add_argument(
        '-i', '--ignore-case', action='store_true',
        help='make all words lowercase')
    parser.add_argument(
        '--max-question', type=int, default=20,
        help='maximum number of words in a question')
    parser.add_argument(
        '--max-answer', type=int, default=40,
        help='maximum number of words in an answer')
    parser.add_argument(
        'vectors',
        help='Embeddings file. Two files are expected to be found: '
             '<vectors>.npy and <vectors>.voc (vocabulary file). Only one '
             'should be informed. The other will be loaded automatically.')
    parser.add_argument('dataset',
                        help='TSV file containing tokenized sentences')
    parser.add_argument('output', help='output file (HDF5)')
    args = parser.parse_args()

    # global parameters
    MAX_QUESTION = args.max_question
    MAX_SENTENCE = args.max_answer

    logging.info('processing: %s' % args.dataset)
    logging.info('output file: %s' % args.output)
    logging.info('ignore case: %s' % args.ignore_case)
    logging.info('max-question: %d, max-answer: %d'
                 % (MAX_QUESTION, MAX_SENTENCE))

    logging.info('loading embeddings: %s' % args.vectors)
    embeddings = load_embeddings(args.vectors)

    hdf = create_outfile(args.output, args.dataset, embeddings.dimension)

    # output datasets
    grp_labels = hdf['data/labels']
    ds_questions = hdf['data/questions']
    ds_sentences = hdf['data/sentences']

    # iterating over input file
    Record = namedtuple('Record', ['qid', 'question', 'sentence', 'label'])
    question = np.array([])
    current_qid = 'no-qid'
    qpos = -1
    labels = []
    logging.info('running sentence decomposition')
    with open(args.dataset) as fin:
        for i, line in enumerate(fin):
            row = Record._make(line.strip().split('\t'))
            if row.qid != current_qid:  # new question
                current_qid = row.qid
                if labels:
                    grp_labels['q%d' % qpos] = np.array(labels, dtype=np.int)
                    labels = []
                qpos += 1
                question = vectorize(row.question, embeddings, MAX_QUESTION,
                                     ignore_case=args.ignore_case)
            sentence = vectorize(row.sentence, embeddings, MAX_SENTENCE,
                                 ignore_case=args.ignore_case)
            labels.append((i, int(row.label)))

            # channel decomposition
            ch_question, ch_sentence = decomp_channels(question, sentence)
            ds_questions[i, ...] = ch_question
            ds_sentences[i, ...] = ch_sentence

        if labels:
            grp_labels['q%d' % qpos] = np.array(labels, dtype=np.int)

    # metadata
    hdf['metadata/questions/count'] = np.array([qpos + 1])
    hdf['metadata/questions/max-size'] = np.array([MAX_QUESTION])
    hdf['metadata/sentences/count'] = np.array([i + 1])
    hdf['metadata/sentences/max-size'] = np.array([MAX_SENTENCE])
    hdf.close()

    logging.info('finished: %s' % args.dataset)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO,
                        format='%(asctime)s %(levelname)s: %(message)s')
    main()
